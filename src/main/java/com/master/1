volatile

1.lock 前缀指令

多个cpu -> 缓存不一致
如何解决？
    通过总线锁和缓存锁
        总线锁会把整个cpu锁住，粒度太大了，
        所以就有了缓存锁（基于缓存一致性协议，著名的"MESI"协议），增加了缓存行的概念。
        但是如果仅仅有缓存一致性协议还不够，因为cpu指令的乱序执行（重排序）可能会导致可见性问题，而在硬件层面很难知道指令前后的依赖性，
        所以在cpu层面又提供了内存屏障的指令，让程序员决定在适当的地方插入指令以防止重排序。

    cpu层面的内存屏障(memory barrier)
        读屏障 -> load memory barrier
        写屏障 -> store memory barrier
        全屏障 -> full memory barrier
        volatile其实就相当于实现了内存屏障

    JMM java内存模型
    编译器 内存屏障将限制重排序优化
    cpu 在编译器生成指令时，会插入内存屏障来禁止处理器重排序



